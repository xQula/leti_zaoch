### Краткое описание предметной области
Предметная область "Склад продуктов" в контексте базы данных включает в себя хранение, учет и управление информацией о товарах, которые находятся на складе. Цель такой базы данных – оптимизация операций по управлению запасами и облегчение процессов логистики. Основные объекты, которые обычно моделируются в базе данных склада продуктов, включают:

Продукты – описание товаров, хранящихся на складе (название, категория, уникальный код, единица измерения и прочее).
Поставщики – данные о компаниях, которые поставляют продукты на склад (название компании, контакты, договоры и условия поставки).
Запасы – информация об объеме и текущем состоянии продуктов на складе (количество, дата поступления, дата истечения срока годности, место хранения).
Заказы – сведения о движении товаров, включая заказы от клиентов, внутренние перемещения и возвраты.
Сотрудники – данные о работниках, которые ответственны за управление складом и учёт продуктов.
Локации хранения – информация о конкретных местах хранения товаров на складе (регионы, стеллажи, ячейки и т.д.).
Использование базы данных для склада продуктов позволяет управлять всеми этими данными, следить за запасами, планировать пополнение, отслеживать сроки годности и контролировать логистику на складе, тем самым улучшая эффективность работы.

### Проектирование БД
Основные таблицы и их поля:
#### Таблица "Продукты"

`product_id (PK)` – уникальный идентификатор продукта  
`name` – наименование продукта  
`category` – категория продукта  
`unit` – единица измерения (штуки, кг, литры и т.д.)  
`description` – описание продукта  

#### Таблица "Поставщики"

`supplier_id (PK)` – уникальный идентификатор поставщика  
`name` – название компании поставщика  
`contact_info` – контактные данные (телефон, email)  
`address` – адрес поставщика  

#### Таблица "Запасы"

`stock_id (PK)` – уникальный идентификатор записи  
`product_id (FK)` – ссылка на таблицу "Продукты"  
`quantity` – количество на складе  
`location_id (FK)` – ссылка на таблицу "Локации хранения"  
`expiry_date` – срок годности, если применимо  
`arrival_date` – дата поступления на склад  

#### Таблица "Локации хранения"

`location_id (PK)` – уникальный идентификатор локации  
`location_name` – название или код ячейки  
`zone` – зона хранения (например, зона охлаждения, зона заморозки)  

#### Таблица "Заказы"

`order_id (PK)` – уникальный идентификатор заказа  
`order_date` – дата заказа  
`customer_id (FK)` – ссылка на таблицу "Клиенты"  
`status` – статус заказа (в процессе, завершен, отменен)  
`total_amount` – общая сумма заказа  

#### Таблица "Заказанные продукты" (для связи между заказами и продуктами)

`order_item_id (PK)` – уникальный идентификатор записи  
`order_id (FK)` – ссылка на таблицу "Заказы"  
`product_id (FK)` – ссылка на таблицу "Продукты"  
`quantity` – количество продукта в заказе  
`price` – цена продукта на момент заказа  

#### Таблица "Клиенты"

`customer_id (PK)` – уникальный идентификатор клиента  
`name` – имя клиента или название компании  
`contact_info` – контактная информация  

### SQL-скрипт для создания базы данных "Склад продуктов":

```postgresql
-- Создание базы данных
CREATE DATABASE product_warehouse;
\c product_warehouse;

-- Создание таблицы "Продукты"
CREATE TABLE Products (
                          product_id SERIAL PRIMARY KEY,
                          name VARCHAR(100) NOT NULL UNIQUE,          -- Название продукта уникально
                          category VARCHAR(50),
                          unit VARCHAR(20) NOT NULL,
                          description TEXT
);

-- Создание таблицы "Поставщики"
CREATE TABLE Suppliers (
                           supplier_id SERIAL PRIMARY KEY,
                           name VARCHAR(100) NOT NULL UNIQUE,          -- Название поставщика уникально
                           contact_info VARCHAR(100),
                           address TEXT
);

-- Создание таблицы "Локации хранения"
CREATE TABLE Locations (
                           location_id SERIAL PRIMARY KEY,
                           location_name VARCHAR(50) NOT NULL UNIQUE,  -- Название локации уникально
                           zone VARCHAR(50)
);

-- Создание таблицы "Запасы"
CREATE TABLE Stock (
                       stock_id SERIAL PRIMARY KEY,
                       product_id INT REFERENCES Products(product_id) ON DELETE CASCADE,
                       quantity INT CHECK (quantity >= 0),         -- Количество не может быть отрицательным
                       location_id INT REFERENCES Locations(location_id) ON DELETE SET NULL,
                       expiry_date DATE CHECK (expiry_date >= arrival_date),  -- Дата истечения >= дате поступления
                       arrival_date DATE NOT NULL,
                       CONSTRAINT min_stock CHECK (quantity >= 10) -- Минимальный запас в 10 единиц
);

-- Создание таблицы "Клиенты"
CREATE TABLE Customers (
                           customer_id SERIAL PRIMARY KEY,
                           name VARCHAR(100) NOT NULL UNIQUE,          -- Имя клиента уникально
                           contact_info VARCHAR(100)
);

-- Создание таблицы "Заказы"
CREATE TABLE Orders (
                        order_id SERIAL PRIMARY KEY,
                        order_date DATE DEFAULT CURRENT_DATE,
                        customer_id INT REFERENCES Customers(customer_id) ON DELETE SET NULL,
                        status VARCHAR(20) CHECK (status IN ('в процессе', 'завершен', 'отменен')),
                        total_amount DECIMAL(10, 2) CHECK (total_amount >= 0),
                        CONSTRAINT check_total_amount CHECK (total_amount >= (
                            SELECT COALESCE(SUM(quantity * price), 0)
                            FROM Order_Items
                            WHERE order_id = Orders.order_id
                        )) -- Сумма заказа должна соответствовать сумме позиций в Order_Items
);

-- Создание таблицы "Заказанные продукты" (связь между заказами и продуктами)
CREATE TABLE Order_Items (
                             order_item_id SERIAL PRIMARY KEY,
                             order_id INT REFERENCES Orders(order_id) ON DELETE CASCADE,
                             product_id INT REFERENCES Products(product_id) ON DELETE CASCADE,
                             quantity INT CHECK (quantity > 0),
                             price DECIMAL(10, 2) CHECK (price >= 0)
);

-- Добавление индексов для ускорения поиска
CREATE INDEX idx_product_id ON Stock(product_id);
CREATE INDEX idx_location_id ON Stock(location_id);
CREATE INDEX idx_order_id ON Order_Items(order_id);
CREATE INDEX idx_customer_id ON Orders(customer_id);

-- Успешное выполнение создания структуры базы данных "Склад продуктов" с дополнительными ограничениями целостности

```

#### Пояснение к скрипту

* SERIAL PRIMARY KEY используется для создания уникальных идентификаторов.
* FOREIGN KEY с опциями ON DELETE CASCADE и ON DELETE SET NULL определяет поведение при удалении связанных записей.
* Поля, такие как quantity и price, имеют ограничения CHECK, чтобы гарантировать, что значения будут положительными.
* Индексы добавлены для ускорения поиска в часто используемых столбцах.

#### Пояснение к добавленным ограничениям:
* UNIQUE: предотвращает дублирование имен в таблицах Products, Suppliers, Locations, и Customers.
* CHECK на expiry_date: убеждает, что срок годности продукта на складе позже или совпадает с датой поступления.
* CHECK на quantity в Stock: устанавливает минимальный запас.
* CHECK на total_amount в Orders: проверяет, что общая сумма заказа соответствует сумме позиций из Order_Items.

### Заполнение базы данных даннами

```postgresql
-- Заполнение таблицы "Продукты"
INSERT INTO Products (name, category, unit, description)
VALUES
    ('Молоко', 'Молочные продукты', 'литр', 'Свежемолочное молоко 3.2% жирности'),
    ('Хлеб', 'Выпечка', 'штука', 'Пшеничный хлеб свежей выпечки'),
    ('Сыр', 'Молочные продукты', 'кг', 'Твердый сыр с выдержкой 6 месяцев'),
    ('Яблоки', 'Фрукты', 'кг', 'Красные яблоки, сорт Гала'),
    ('Макароны', 'Бакалея', 'кг', 'Макароны из твердых сортов пшеницы');

-- Заполнение таблицы "Поставщики"
INSERT INTO Suppliers (name, contact_info, address)
VALUES
    ('Фермерское хозяйство "Зеленый край"', 'email1@example.com, +7 123 456 7890', 'г. Москва, ул. Ленина, 1'),
    ('Хлебозавод №3', 'email2@example.com, +7 123 456 7891', 'г. Москва, ул. Рязанская, 5'),
    ('Сыроварня "Сырный мир"', 'email3@example.com, +7 123 456 7892', 'г. Санкт-Петербург, ул. Пушкина, 10');

-- Заполнение таблицы "Локации хранения"
INSERT INTO Locations (location_name, zone)
VALUES
    ('Холодильник 1', 'Зона охлаждения'),
    ('Полка 3', 'Сухое хранение'),
    ('Полка 1', 'Сухое хранение'),
    ('Холодильник 2', 'Зона заморозки');

-- Заполнение таблицы "Запасы"
INSERT INTO Stock (product_id, quantity, location_id, expiry_date, arrival_date)
VALUES
    (1, 100, 1, '2024-12-31', '2024-10-01'),  -- Молоко
    (2, 50, 2, NULL, '2024-11-01'),           -- Хлеб
    (3, 30, 1, '2025-06-01', '2024-11-05'),   -- Сыр
    (4, 70, 2, '2024-12-15', '2024-11-10'),   -- Яблоки
    (5, 200, 3, NULL, '2024-11-12');          -- Макароны

-- Заполнение таблицы "Клиенты"
INSERT INTO Customers (name, contact_info)
VALUES
    ('ООО "Вкусная еда"', 'contact1@example.com, +7 987 654 3210'),
    ('Магазин "Фруктовый сад"', 'contact2@example.com, +7 987 654 3211'),
    ('ИП Иванов И.И.', 'contact3@example.com, +7 987 654 3212');

-- Заполнение таблицы "Заказы"
INSERT INTO Orders (order_date, customer_id, status, total_amount)
VALUES
    ('2024-11-10', 1, 'в процессе', 1500.00),
    ('2024-11-12', 2, 'завершен', 800.00),
    ('2024-11-15', 3, 'в процессе', 1200.00);

-- Заполнение таблицы "Заказанные продукты"
INSERT INTO Order_Items (order_id, product_id, quantity, price)
VALUES
    (1, 1, 20, 50.00),    -- Заказ 1, Молоко
    (1, 2, 10, 20.00),    -- Заказ 1, Хлеб
    (2, 4, 15, 20.00),    -- Заказ 2, Яблоки
    (3, 5, 30, 40.00),    -- Заказ 3, Макароны
    (3, 3, 5, 120.00);    -- Заказ 3, Сыр

```

#### Пояснение к данным
* Продукты: несколько продуктов разных категорий (молочные, выпечка, фрукты, бакалея).
* Поставщики: информация о поставщиках продуктов, включая контактные данные.
* Локации хранения: зоны на складе, такие как холодильники и полки.
* Запасы: товары, их количество на складе, места хранения и сроки годности.
* Клиенты: добавлены примеры компаний и частных предпринимателей.
* Заказы и Заказанные продукты: каждый заказ имеет связанные продукты и цены.

### Разработка объектов промежуточного слоя (представлений, хранимых процедур, UDF-ов)

#### Представления (Views)

Представления позволяют упростить доступ к информации, представляя комплексные запросы в виде одной таблицы.

1. Представление для текущего наличия товаров на складе
   Это представление покажет информацию о каждом товаре, его количестве на складе и сроке годности.
```postgresql
   CREATE VIEW Current_Stock AS
SELECT
p.name AS product_name,
s.quantity,
l.location_name,
s.arrival_date,
s.expiry_date
FROM Stock s
JOIN Products p ON s.product_id = p.product_id
JOIN Locations l ON s.location_id = l.location_id
WHERE s.quantity > 0;
   ```

2. Представление для заказов и заказанных товаров
   Это представление покажет информацию о каждом заказе, включая данные о заказанных товарах.

```postgresql
CREATE VIEW Order_Details AS
SELECT 
    o.order_id,
    o.order_date,
    c.name AS customer_name,
    p.name AS product_name,
    oi.quantity,
    oi.price,
    (oi.quantity * oi.price) AS total_price
FROM Orders o
JOIN Customers c ON o.customer_id = c.customer_id
JOIN Order_Items oi ON o.order_id = oi.order_id
JOIN Products p ON oi.product_id = p.product_id;

```

#### Хранимые процедуры (Stored Procedures)

Хранимые процедуры позволяют выполнять комплексные операции, такие как добавление нового товара на склад или создание нового заказа.

1. Процедура для добавления нового товара на склад
   Эта процедура добавляет запись в таблицу Stock.

```postgresql
CREATE OR REPLACE PROCEDURE Add_Stock(
    _product_id INT,
    _quantity INT,
    _location_id INT,
    _arrival_date DATE,
    _expiry_date DATE
)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO Stock (product_id, quantity, location_id, arrival_date, expiry_date)
    VALUES (_product_id, _quantity, _location_id, _arrival_date, _expiry_date);
END;
$$;
```

2. Процедура для создания нового заказа
   Эта процедура создает новый заказ и добавляет товары к заказу.

```postgresql
CREATE OR REPLACE PROCEDURE Create_Order(
    _customer_id INT,
    _status VARCHAR(20),
    _total_amount DECIMAL,
    _order_date DATE DEFAULT CURRENT_DATE
)
LANGUAGE plpgsql
AS $$
DECLARE
    _order_id INT;
BEGIN
    -- Вставка нового заказа
    INSERT INTO Orders (order_date, customer_id, status, total_amount)
    VALUES (_order_date, _customer_id, _status, _total_amount)
    RETURNING order_id INTO _order_id;
    
    -- Дополнительная логика для добавления позиций к заказу может быть добавлена здесь
END;
$$;
```

#### Пользовательские функции (User-Defined Functions)

Функции помогают выполнять вычисления или возвращать значения, которые могут использоваться в запросах.

1. Функция для вычисления общей стоимости заказа
   Эта функция принимает идентификатор заказа и возвращает общую стоимость всех товаров в заказе.

```postgresql
CREATE OR REPLACE FUNCTION Calculate_Order_Total(_order_id INT)
RETURNS DECIMAL AS $$
DECLARE
    _total DECIMAL;
BEGIN
    SELECT SUM(quantity * price) INTO _total
    FROM Order_Items
    WHERE order_id = _order_id;
    RETURN COALESCE(_total, 0);
END;
$$ LANGUAGE plpgsql;
```

2. Функция для получения количества оставшихся товаров с учетом минимального запаса
   Функция принимает идентификатор товара и возвращает оставшееся количество с учетом минимального запаса.

```postgresql
CREATE OR REPLACE FUNCTION Remaining_Stock(_product_id INT)
RETURNS INT AS $$
DECLARE
    _remaining INT;
BEGIN
    SELECT quantity - 10 INTO _remaining  -- 10 – минимальный запас
    FROM Stock
    WHERE product_id = _product_id;
    RETURN GREATEST(_remaining, 0);
END;
$$ LANGUAGE plpgsql;
```

#### Примеры использования 
1. Представления: Можно выполнить запрос SELECT * FROM Current_Stock; для получения всех товаров на складе.
2. Процедуры: Вызвать процедуру CALL Add_Stock(1, 50, 2, '2024-11-01', '2024-12-01');, чтобы добавить товар на склад.
3. Функции: Использовать SELECT Calculate_Order_Total(1); для вычисления общей стоимости заказа.

### Резервное копирование

Резервное копирование является важнейшей частью стратегии обеспечения надежности базы данных. Для PostgreSQL существует несколько подходов к резервному копированию, каждый из которых предназначен для разных задач: от создания копий для быстрого восстановления до обеспечения защиты от сбоев на уровне системы. Я предложу стратегию резервного копирования, которая учитывает потребности в доступности и минимальном времени простоя.

#### Основные типы резервного копирования в PostgreSQL

1. `Полное резервное копирование (Full Backup)` — копия всей базы данных. Это резервное копирование проводится регулярно и позволяет восстановить данные на момент создания копии.
2. `Инкрементное резервное копирование (Incremental Backup)` — хранит изменения, произошедшие после последнего полного резервного копирования, что позволяет экономить место и ресурсы.
3. `Архивация WAL (Write-Ahead Logging)` — позволяет восстанавливать базу данных до любой точки во времени с момента последнего полного резервного копирования, регистрируя все операции.
4. `Снимки (Snapshot-based Backup)` — используются для резервного копирования базы данных в виртуализированных или облачных средах, но требуют специальных настроек.

#### Стратегия резервного копирования

1. Полное резервное копирование
   * Частота: 1 раз в неделю (например, каждое воскресенье ночью).
     * Инструмент: pg_dump или pg_basebackup.
       * Хранение: сохранять не менее 4 последних полных копий (около месяца), чтобы иметь возможность восстановления в случае, если сбой был замечен не сразу.

Пример команды с использованием pg_dump:
```bash
pg_dump -U postgres -F c -b -v -f /backup/warehouse_backup_$(date +\%Y\%m\%d).backup product_warehouse
```

2. Инкрементное резервное копирование
   * Частота: ежедневно, между полными копиями.
   * Инструмент: инкрементное копирование данных с использованием WAL.
   * Хранение: сохранять не менее 7 дней инкрементных файлов.

Пример настройки WAL-архивирования: В PostgreSQL конфигурационном файле postgresql.conf нужно настроить:
```conf
archive_mode = on
archive_command = 'cp %p /backup/wal/%f'
```

3. Резервное копирование WAL-логов
   * Частота: непрерывно, по мере появления новых записей в WAL.
   * Инструмент: включенное архивирование WAL.
   * Хранение: для восстановления к точке времени в пределах последних 7 дней.
4. Тестирование восстановления (Recovery Testing)
   * Частота: не реже одного раза в месяц тестировать восстановление на резервном сервере.
   * Процесс: восстанавливать базу данных из полного бэкапа, а затем применять WAL-журналы, чтобы убедиться, что можно восстановить данные до любого нужного момента времени.

#### Автоматизация резервного копирования
Для обеспечения стабильного выполнения резервного копирования можно использовать задачи планировщика (например, cron на Linux).

Пример конфигурации cron для автоматического резервного копирования:

1. Полное резервное копирование раз в неделю:
```bash
0 2 * * 0 /usr/bin/pg_dump -U postgres -F c -b -v -f /backup/warehouse_backup_$(date +\%Y\%m\%d).backup product_warehouse
```

2. Инкрементное резервное копирование WAL:
```bash
0 * * * * cp /path/to/pg_wal/* /backup/wal/  # Архивация WAL-логов каждый час
```

#### Хранение и ротация резервных копий

* Местное хранилище: хранить резервные копии локально для быстрого восстановления.
* Внешнее хранилище: копии должны также быть размещены на удаленном сервере или облачном хранилище.
* Ротация: настроить удаление старых копий (например, старше 30 дней).

Пример скрипта для ротации копий:
```bash
find /backup/ -type f -name "*.backup" -mtime +30 -exec rm {} \;
```

#### План восстановления

1. В случае сбоя
   * Восстановить базу из последней полной копии.
   * Применить WAL-логи для восстановления до конкретной точки.
2. Проверка целостности данных после восстановления.